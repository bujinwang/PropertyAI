const axios = require('axios');
const NodeCache = require('node-cache');
const { PrismaClient } = require('@prisma/client');
const prisma = new PrismaClient();

// Initialize cache with 1 hour TTL
const cache = new NodeCache({ stdTTL: 3600, checkperiod: 600 });

// Mock market data for development (replace with real API calls)
const mockMarketData = {
  '10001': { // NYC zip code
    avgRent1BR: 3200,
    avgRent2BR: 4500,
    avgRent3BR: 6200,
    medianPrice: 850000,
    vacancyRate: 3.2,
    marketTrend: 'increasing',
    trendPercentage: 5.8,
    comparableProperties: [
      { address: '123 Main St', rent: 3300, sqft: 800, beds: 1 },
      { address: '456 Oak Ave', rent: 3100, sqft: 750, beds: 1 },
      { address: '789 Pine St', rent: 4600, sqft: 1100, beds: 2 }
    ]
  },
  '90210': { // Beverly Hills zip code
    avgRent1BR: 3800,
    avgRent2BR: 5500,
    avgRent3BR: 7800,
    medianPrice: 2500000,
    vacancyRate: 2.8,
    marketTrend: 'stable',
    trendPercentage: 1.2,
    comparableProperties: [
      { address: '100 Rodeo Dr', rent: 3900, sqft: 900, beds: 1 },
      { address: '200 Wilshire Blvd', rent: 5300, sqft: 1200, beds: 2 },
      { address: '300 Sunset Blvd', rent: 7600, sqft: 1500, beds: 3 }
    ]
  }
};

class MarketDataService {
  constructor() {
    this.apiKeys = {
      realtor: process.env.REALTOR_API_KEY || 'demo_key',
      zillow: process.env.ZILLOW_API_KEY || 'demo_key'
    };
    this.rateLimits = {
      realtor: { requests: 0, resetTime: Date.now() + 3600000 },
      zillow: { requests: 0, resetTime: Date.now() + 3600000 }
    };
    // Circuit Breaker configuration
    this.circuitBreakers = {
      realtor: { state: 'CLOSED', failureCount: 0, lastFailure: null, timeout: 60000 },
      zillow: { state: 'CLOSED', failureCount: 0, lastFailure: null, timeout: 60000 }
    };
    // Performance monitoring
    this.performanceMetrics = {
      realtor: { totalCalls: 0, totalTime: 0, avgTime: 0 },
      zillow: { totalCalls: 0, totalTime: 0, avgTime: 0 }
    };
  }

  // Circuit Breaker methods
  getCircuitBreakerState(provider) {
    return this.circuitBreakers[provider].state;
  }

  updateCircuitBreaker(provider, success = true) {
    const cb = this.circuitBreakers[provider];
    const now = Date.now();

    if (success) {
      cb.failureCount = 0;
      if (cb.state === 'OPEN') {
        cb.state = 'HALF_OPEN';
        cb.lastFailure = now;
      } else {
        cb.state = 'CLOSED';
      }
    } else {
      cb.failureCount++;
      cb.lastFailure = now;
      if (cb.failureCount >= 5 && cb.state === 'CLOSED') { // 5 consecutive failures
        cb.state = 'OPEN';
      }
    }
  }

  shouldAllowRequest(provider) {
    const cb = this.circuitBreakers[provider];
    if (cb.state === 'CLOSED') return true;
    if (cb.state === 'OPEN') {
      // Check if timeout has passed
      if (Date.now() - cb.lastFailure > cb.timeout) {
        cb.state = 'HALF_OPEN';
        return true;
      }
      return false;
    }
    // HALF_OPEN: allow one request to test
    return true;
  }

  // Performance monitoring wrapper
  async withPerformanceMonitoring(provider, operation) {
    const startTime = performance.now();
    this.performanceMetrics[provider].totalCalls++;
    
    try {
      const result = await operation();
      const endTime = performance.now();
      const responseTime = endTime - startTime;
      this.performanceMetrics[provider].totalTime += responseTime;
      this.performanceMetrics[provider].avgTime = this.performanceMetrics[provider].totalTime / this.performanceMetrics[provider].totalCalls;
      
      console.log(`[${provider.toUpperCase()}] Response time: ${responseTime.toFixed(2)}ms (avg: ${this.performanceMetrics[provider].avgTime.toFixed(2)}ms)`);
      return result;
    } catch (error) {
      const endTime = performance.now();
      const responseTime = endTime - startTime;
      console.log(`[${provider.toUpperCase()}] ERROR - Response time: ${responseTime.toFixed(2)}ms`);
      throw error;
    }
  }

  // Check rate limits
  checkRateLimit(provider) {
    const now = Date.now();
    if (now > this.rateLimits[provider].resetTime) {
      this.rateLimits[provider] = { requests: 0, resetTime: now + 3600000 };
    }
    return this.rateLimits[provider].requests < 1000; // 1000 requests per hour
  }

  // Increment rate limit counter
  incrementRateLimit(provider) {
    this.rateLimits[provider].requests++;
  }

  // Fetch market data from external APIs
  async fetchMarketData(zipCode, propertyType = 'residential') {
    const cacheKey = `market_${zipCode}_${propertyType}`;

    // Check cache first
    const cachedData = cache.get(cacheKey);
    if (cachedData) {
      return cachedData;
    }

    try {
      // Try primary provider (Realtor)
      if (this.checkRateLimit('realtor')) {
        this.incrementRateLimit('realtor');
        const data = await this.fetchFromRealtor(zipCode, propertyType);
        if (data) {
          cache.set(cacheKey, data);
          return data;
        }
      }

      // Try backup provider (Zillow)
      if (this.checkRateLimit('zillow')) {
        this.incrementRateLimit('zillow');
        const data = await this.fetchFromZillow(zipCode, propertyType);
        if (data) {
          cache.set(cacheKey, data);
          return data;
        }
      }

      // Fallback to mock data
      console.warn(`Using mock data for zip code ${zipCode}`);
      const mockData = mockMarketData[zipCode] || this.generateFallbackData(zipCode);
      cache.set(cacheKey, mockData);
      return mockData;

    } catch (error) {
      console.error('Error fetching market data:', error);
      // Return cached data if available, otherwise fallback
      return cachedData || this.generateFallbackData(zipCode);
    }
  }

  // Fetch from Realtor API (production implementation with circuit breaker and monitoring)
  async fetchFromRealtor(zipCode, propertyType) {
    if (!this.shouldAllowRequest('realtor')) {
      console.warn('Realtor circuit breaker OPEN - using fallback');
      this.updateCircuitBreaker('realtor', false);
      return null;
    }

    try {
      return await this.withPerformanceMonitoring('realtor', async () => {
        const apiKey = this.apiKeys.realtor;
        if (!apiKey || apiKey === 'demo_key') {
          console.warn('Realtor API key not configured, using fallback');
          throw new Error('API key not configured');
        }

        // Realtor API endpoint for market data (example endpoint - adjust based on actual API)
        const response = await axios.get(`https://api.realtor.com/v1/market-insights`, {
          params: {
            zipCode,
            propertyType,
            api_key: apiKey
          },
          timeout: 10000, // 10 second timeout
          headers: {
            'User-Agent': 'PropertyAI/1.0',
            'Accept': 'application/json'
          }
        });

        if (response.status === 200 && response.data) {
          const data = response.data;
          const result = {
            avgRent1BR: data.avgRent1BR || data.rentData?.oneBedroom,
            avgRent2BR: data.avgRent2BR || data.rentData?.twoBedroom,
            avgRent3BR: data.avgRent3BR || data.rentData?.threeBedroom,
            medianPrice: data.medianPrice,
            vacancyRate: data.vacancyRate || 3.5, // Default if not available
            marketTrend: data.marketTrend || this.determineTrend(data.priceChange),
            trendPercentage: data.trendPercentage || data.priceChange || 0,
            comparableProperties: data.comparableProperties || [],
            source: 'realtor',
            lastUpdated: new Date().toISOString(),
            confidence: 90 // Higher confidence for primary source
          };
          this.updateCircuitBreaker('realtor', true);
          return result;
        } else {
          throw new Error('Invalid response from Realtor API');
        }
      });
    } catch (error) {
      this.updateCircuitBreaker('realtor', false);
      if (error.response?.status === 429) {
        console.warn('Realtor API rate limit exceeded');
      } else if (error.code === 'ECONNABORTED') {
        console.warn('Realtor API timeout');
      } else if (error.message === 'API key not configured') {
        console.warn('Realtor API key not configured, using fallback');
      } else {
        console.error('Realtor API error:', error.message);
      }
      return null;
    }
  }

  // Fetch from Zillow API (production implementation with circuit breaker and monitoring)
  async fetchFromZillow(zipCode, propertyType) {
    if (!this.shouldAllowRequest('zillow')) {
      console.warn('Zillow circuit breaker OPEN - using fallback');
      this.updateCircuitBreaker('zillow', false);
      return null;
    }

    try {
      return await this.withPerformanceMonitoring('zillow', async () => {
        const apiKey = this.apiKeys.zillow;
        if (!apiKey || apiKey === 'demo_key') {
          console.warn('Zillow API key not configured, using fallback');
          throw new Error('API key not configured');
        }

        // Zillow API endpoint for market data (using Zillow Research API or similar)
        const response = await axios.get(`https://www.zillow.com/webservice/GetRegionChildren.htm`, {
          params: {
            zws_id: apiKey,
            state: 'NY', // Extract state from zipCode if needed
            city: 'New York', // Extract city from zipCode
            zipcode: zipCode
          },
          timeout: 10000, // 10 second timeout
          headers: {
            'User-Agent': 'PropertyAI/1.0',
            'Accept': 'application/json'
          }
        });

        if (response.status === 200 && response.data) {
          const data = response.data.response;
          if (data.region && data.region[0]) {
            const region = data.region[0];
            const result = {
              avgRent1BR: region.zestimate?.oneBed || 1500, // Map to available fields
              avgRent2BR: region.zestimate?.twoBed || 2000,
              avgRent3BR: region.zestimate?.threeBed || 2500,
              medianPrice: region.zestimate?.value || 500000,
              vacancyRate: 3.5, // Zillow may not provide directly, use default or calculate
              marketTrend: this.determineTrend(region.priceChange),
              trendPercentage: region.priceChange?.lastMonth || 0,
              comparableProperties: [], // Zillow comparables may require separate endpoint
              source: 'zillow',
              lastUpdated: new Date().toISOString(),
              confidence: 85 // Slightly lower than primary
            };
            this.updateCircuitBreaker('zillow', true);
            return result;
          } else {
            throw new Error('No region data from Zillow API');
          }
        } else {
          throw new Error('Invalid response from Zillow API');
        }
      });
    } catch (error) {
      this.updateCircuitBreaker('zillow', false);
      if (error.response?.status === 429) {
        console.warn('Zillow API rate limit exceeded');
      } else if (error.code === 'ECONNABORTED') {
        console.warn('Zillow API timeout');
      } else if (error.message === 'API key not configured') {
        console.warn('Zillow API key not configured, using fallback');
      } else {
        console.error('Zillow API error:', error.message);
      }
      return null;
    }
  }

  // Helper method to determine trend from price change data
  determineTrend(priceChange) {
    if (priceChange > 2) return 'increasing';
    if (priceChange < -2) return 'decreasing';
    return 'stable';
  }

  // Generate fallback data when APIs are unavailable
  generateFallbackData(zipCode) {
    const baseRent = 2500 + Math.random() * 2000; // $2500-$4500 range
    return {
      avgRent1BR: Math.round(baseRent * 0.8),
      avgRent2BR: Math.round(baseRent * 1.2),
      avgRent3BR: Math.round(baseRent * 1.6),
      medianPrice: Math.round(baseRent * 200), // Rough estimate
      vacancyRate: 3.0 + Math.random() * 4.0, // 3-7% range
      marketTrend: Math.random() > 0.5 ? 'increasing' : 'stable',
      trendPercentage: Math.round((Math.random() * 10 - 2) * 10) / 10, // -2% to +8%
      source: 'fallback',
      lastUpdated: new Date().toISOString(),
      confidence: 50,
      comparableProperties: []
    };
  }

  // Get pricing recommendations
  async getPricingRecommendations(propertyId) {
    try {
      const property = await prisma.property.findUnique({
        where: { id: propertyId }
      });
      if (!property) {
        throw new Error('Property not found');
      }

      const marketData = await this.fetchMarketData(property.zipCode);
      const currentRent = property.monthlyRent || 0;

      // Calculate recommendations based on market data
      const recommendations = [];

      // Determine appropriate rent based on bedrooms
      let targetRent;
      switch (property.bedrooms) {
        case 1:
          targetRent = marketData.avgRent1BR;
          break;
        case 2:
          targetRent = marketData.avgRent2BR;
          break;
        case 3:
        default:
          targetRent = marketData.avgRent3BR;
          break;
      }

      // Calculate price difference
      const difference = targetRent - currentRent;
      const percentageDiff = currentRent > 0 ? (difference / currentRent) * 100 : 0;

      if (Math.abs(percentageDiff) > 5) { // More than 5% difference
        const direction = difference > 0 ? 'increase' : 'decrease';
        const confidence = Math.min(90, marketData.confidence);

        recommendations.push({
          type: 'rent_adjustment',
          action: `${direction} rent by ${Math.abs(percentageDiff).toFixed(1)}%`,
          targetRent: Math.round(targetRent),
          currentRent: Math.round(currentRent),
          marketAverage: Math.round(targetRent),
          confidence: Math.round(confidence),
          reasoning: `Market average for ${property.bedrooms}BR is $${targetRent}. Current rent is ${Math.abs(percentageDiff).toFixed(1)}% ${direction === 'increase' ? 'below' : 'above'} market rate.`,
          marketTrend: marketData.marketTrend,
          trendPercentage: marketData.trendPercentage
        });
      } else {
        recommendations.push({
          type: 'maintain',
          action: 'Current rent is competitive',
          targetRent: Math.round(currentRent),
          currentRent: Math.round(currentRent),
          marketAverage: Math.round(targetRent),
          confidence: Math.round(marketData.confidence),
          reasoning: `Current rent is within 5% of market average for ${property.bedrooms}BR units.`
        });
      }

      return {
        propertyId,
        recommendations,
        marketData: {
          zipCode: property.zipCode,
          marketTrend: marketData.marketTrend,
          trendPercentage: marketData.trendPercentage,
          vacancyRate: marketData.vacancyRate,
          source: marketData.source,
          lastUpdated: marketData.lastUpdated
        }
      };

    } catch (error) {
      console.error('Error getting pricing recommendations:', error);
      return {
        propertyId,
        error: 'Failed to generate pricing recommendations',
        recommendations: []
      };
    }
  }

  // Get competitive analysis
  async getCompetitiveAnalysis(propertyId) {
    try {
      const property = await prisma.property.findUnique({
        where: { id: propertyId }
      });
      if (!property) {
        throw new Error('Property not found');
      }

      const marketData = await this.fetchMarketData(property.zipCode);

      // Calculate positioning
      let marketPosition = 'average';
      const currentRent = property.monthlyRent || 0;

      let targetRent;
      switch (property.bedrooms) {
        case 1:
          targetRent = marketData.avgRent1BR;
          break;
        case 2:
          targetRent = marketData.avgRent2BR;
          break;
        case 3:
        default:
          targetRent = marketData.avgRent3BR;
          break;
      }

      const difference = ((currentRent - targetRent) / targetRent) * 100;

      if (difference > 10) {
        marketPosition = 'premium';
      } else if (difference < -10) {
        marketPosition = 'value';
      }

      // Generate insights
      const insights = [];

      if (marketData.marketTrend === 'increasing') {
        insights.push(`Market is trending upward by ${marketData.trendPercentage}%. Consider gradual rent increases.`);
      } else if (marketData.marketTrend === 'decreasing') {
        insights.push(`Market is declining by ${Math.abs(marketData.trendPercentage)}%. Consider maintaining current rents.`);
      }

      if (marketData.vacancyRate < 3) {
        insights.push('Low vacancy rate indicates strong demand. Current pricing strategy is effective.');
      } else if (marketData.vacancyRate > 6) {
        insights.push('High vacancy rate suggests pricing may be too aggressive. Consider rent reductions.');
      }

      // Find similar properties
      const similarProperties = marketData.comparableProperties || [];
      const matches = similarProperties.filter(comp =>
        Math.abs(comp.beds - property.bedrooms) <= 1 &&
        Math.abs(comp.sqft - (property.squareFootage || 1000)) <= 200
      );

      return {
        propertyId,
        marketPosition,
        marketDifference: Math.round(difference),
        insights,
        comparableProperties: matches.slice(0, 3),
        marketData: {
          zipCode: property.zipCode,
          vacancyRate: marketData.vacancyRate,
          marketTrend: marketData.marketTrend,
          trendPercentage: marketData.trendPercentage,
          source: marketData.source,
          lastUpdated: marketData.lastUpdated
        }
      };

    } catch (error) {
      console.error('Error getting competitive analysis:', error);
      return {
        propertyId,
        error: 'Failed to generate competitive analysis',
        marketPosition: 'unknown',
        insights: []
      };
    }
  }

  // Get market trends for dashboard
  async getMarketTrends(zipCode, months = 12) {
    try {
      const marketData = await this.fetchMarketData(zipCode);

      // Generate historical trend data (mock for now)
      const trends = [];
      const baseDate = new Date();

      for (let i = months - 1; i >= 0; i--) {
        const date = new Date(baseDate);
        date.setMonth(date.getMonth() - i);

        // Simulate trend based on market data
        const trendMultiplier = 1 + (marketData.trendPercentage / 100) * (i / (months - 1));
        const avgRent = Math.round(marketData.avgRent2BR * trendMultiplier);

        trends.push({
          date: date.toISOString().split('T')[0],
          avgRent2BR: avgRent,
          vacancyRate: Math.max(0, marketData.vacancyRate + (Math.random() - 0.5) * 2)
        });
      }

      return {
        zipCode,
        trends,
        current: {
          avgRent2BR: marketData.avgRent2BR,
          vacancyRate: marketData.vacancyRate,
          marketTrend: marketData.marketTrend,
          trendPercentage: marketData.trendPercentage
        },
        source: marketData.source,
        lastUpdated: marketData.lastUpdated
      };

    } catch (error) {
      console.error('Error getting market trends:', error);
      return {
        zipCode,
        error: 'Failed to retrieve market trends',
        trends: []
      };
    }
  }
}

module.exports = new MarketDataService();