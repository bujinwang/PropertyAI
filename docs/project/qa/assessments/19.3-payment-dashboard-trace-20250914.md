# Requirements Traceability Matrix

## Story: 19.3 - Payment Dashboard and Notifications

### Coverage Summary

- Total Requirements: 7
- Fully Covered: 7 (100%)
- Partially Covered: 0 (0%)
- Not Covered: 0 (0%)

### Requirement Mappings

#### AC1: Dashboard 'Payments' tab with history

**Coverage: FULL**

Given-When-Then Mappings:

- **Unit Test**: PaymentHistory.test.tsx::renders payment history data
  - Given: Mock payments data loaded via useQuery
  - When: Component renders in Dashboard tab
  - Then: DataGrid displays invoice #, amount, status, date columns correctly

- **Integration Test**: paymentRoutes.test.js::/history API returns filtered data
  - Given: Authenticated user with role 'tenant' or 'owner'
  - When: GET /history called with optional filters (status, date range)
  - Then: Returns array of payments with joined Invoice/Tenant data, ordered by date

#### AC2: Display details in responsive table

**Coverage: FULL**

- **Unit Test**: PaymentHistory.test.tsx::Status Chip renders correctly
  - Given: Payment row with status 'paid' or 'pending'
  - When: DataGrid cell for status renders
  - Then: MUI Chip with appropriate color (green for paid, orange for pending) displayed

- **Unit Test**: PaymentHistory.test.tsx::Responsive breakpoints apply
  - Given: Mobile viewport width (<600px)
  - When: DataGrid renders
  - Then: Columns stack or hide non-essential fields, maintaining readability

#### AC3: Notifications for payment events

**Coverage: FULL**

- **Unit Test**: notificationService.test.js::sendPaymentNotification generates correct messages (extended)
  - Given: Payment event type ('due', 'paid', 'failed', 'overdue') and invoice details
  - When: sendPaymentNotification called
  - Then: Correct message formatted and mock sendEmail/sendPush invoked for tenant

- **Integration Test**: paymentRoutes.test.js::webhook succeeded triggers notification
  - Given: Pending payment record
  - When: payment_intent.succeeded webhook processed
  - Then: notifyPaymentSuccess called with payment details after status update

#### AC4: Stripe webhooks update statuses

**Coverage: FULL**

- **Integration Test**: paymentRoutes.test.js::handles payment_intent.succeeded event
  - Given: Pending Payment and Invoice records
  - When: succeeded webhook event received and verified
  - Then: Payment status to 'paid', Invoice to 'paid', notification triggered

- **Integration Test**: paymentRoutes.test.js::handles payment_intent.payment_failed event
  - Given: Pending Payment record
  - When: failed webhook event received
  - Then: Payment status to 'failed', notifyPaymentFailed called

#### AC5: Auth protected; real-time updates via polling

**Coverage: FULL**

- **Unit Test**: PaymentHistory.test.tsx::useQuery polls every 30s
  - Given: Component mounted with initial data
  - When: 30 seconds elapse
  - Then: useQuery refetches data from /history endpoint

- **Integration Test**: paymentRoutes.test.js::/history requires auth
  - Given: Unauthorized request
  - When: GET /history called without JWT
  - Then: 401 Unauthorized response

#### AC6: Test coverage 95% for component/service/webhook handler

**Coverage: FULL**

- **Coverage Test**: Coverage verification across files
  - Given: All implemented code paths
  - When: jest --coverage run
  - Then: 95%+ coverage for PaymentHistory.tsx, paymentRoutes.test.js, notificationService

#### AC7: Mobile responsive; accessibility WCAG AA

**Coverage: FULL**

- **Unit Test**: PaymentHistory.test.tsx::has proper ARIA labels
  - Given: DataGrid rendered
  - When: Accessibility tree inspected
  - Then: aria-label="Payment history table" present, cells have ARIA descriptions

### Critical Gaps

None identified. All ACs have appropriate test coverage at correct levels.

### Test Design Recommendations

1. Add E2E test for full user journey (login → Dashboard → Payments tab → filter → verify data)
2. Consider snapshot tests for DataGrid renders
3. Add load test for /history with 1000 records

### Risk Assessment

- **Low Risk**: All critical paths (webhook, notifications) fully tested
- **Medium Risk**: Polling could be optimized; monitor in prod